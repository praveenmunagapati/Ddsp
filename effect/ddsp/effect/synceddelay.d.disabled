module ddsp.effect.synceddelay;

import ddsp.effect.digitaldelay;
import ddsp.effect.aeffect;
import ddsp.util.time;

class SyncedDelay : AEffect
{
    import dplug.core.nogc;
public:
    this()
    {
        delay = mallocEmplace!DigitalDelay();
        
        _hostIsPlaying = false;
        waitingForStart = false;
    }
    ~this()
    {
        delay.destroyFree(); 
    }
    
    void initialize(float sampleRate, float feedback, float mix)
    {
        _sampleRate = sampleRate;
        delay.initialize(sampleRate, 2000, 0, feedback, mix);
        delay.reset();
        waitingForStart = true;
    }
    
    void update(Note delayNote, float tempo, long timeInSamples, bool hostIsPlaying, float feedback, float mix)
    {
        _hostIsPlaying = hostIsPlaying;
        float delayAmount = delayNote.getTimeInMilliseconds(tempo);
        delay.update(delayAmount, feedback, mix);
        
        // Check to see if the current possition in samples is evenly divided by the delay amount
        if(_timeInSamples % delayAmount == 0)
        {
            waitingForStart = false;
        }
    }
    
    override float getNextSample(float input)
    {
        float output = 0.0f;
        if(!waitingForStart && _hostIsPlaying)
        {
            output = delay.getNextSample(input);
        }
        else
        {
            output = 0.0f;
        }
        
        return output;
    }
    
    override void reset()
    {
        
    }
    

private:

    DigitalDelay delay;
    
    bool waitingForStart;
    bool _hostIsPlaying;
    
    long _timeInSamples;
}

unittest
{
    import dplug.core.nogc;
    import ddsp.effect.aeffect;

    SyncedDelay delay = mallocEmplace!SyncedDelay;
    delay.initialize(44100, 0.5, 0.5);
    Note note = Note(whole, 1);
    delay.update(note, 120, long timeInSamples, true, 0.5f, 0.5f);
    testEffect(delay, "Synced Delay", 44000, true);
}