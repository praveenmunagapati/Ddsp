module ddsp.effect.moddelay;

enum : int
{
    flanger,
    vibrato,
    chorus
}

class ModDelay : AEffect
{
public:
    import ddsp.effect.aeffect;
    import ddsp.effect.ddelay;
    import ddsp.osc.cfoscillator;
    
    this() nothrow @nogc
    {
        delayLine = mallocEmplace!DDelay();
        oscillator = mallocEmplace!CFOscillator();
        
        minDelay = 0.0f;
        maxDelay = 0.0f;
        chorusOffset = 0.0f;
        
        //delayLine.setDelayMS(0);
        //oscillator.setFrequency(0);
        
    }
    
    ~this() nothrow @nogc
    {
        
    }
    
    void initialize(float sampleRate, float feedback, uint modType) nothrow @nogc
    {
        _sampleRate = sampleRate;
        _feedback = feedback;
        _type = modType;
    }
    
    void updateLFO(float frequency) nothrow @nogc
    {
        oscillator.setFrequency(frequency);
    }
    
    void updateDDL() nothrow @nogc
    {
        
    }
    
    void cookModType() nothrow @nogc
    {
        switch(_type)
        {
            case flanger:
            {
                minDelayMS = 0;
                maxDelayMS = 7;
                delayLine.setMix(0.5);
                delayLine.setFeedback(_feedback);
                break;
            }
            case vibrato:
            {
                minDelayMS = 0;
                maxDelayMS = 7;
                delayLine.setMix(1.0f);
                delayLine.setFeedback(0.0f);
                break;
            }
            case chorus:
            {
                minDelayMS = 5;
                maxDelayMS = 30;
                delayLine.setMix(0.5f);
                delayLine.setFeedback(0.0f);
                //delayLine.setInputAttentuation(1.0f);
                break;
            }
            default:
            {
                minDelayMS = 0;
                maxDelayMS = 7;
                delayLine.setMix(0.5);
                delayLine.setFeedback(_feedback);
                break;
            }
        }
    }
    
    float calculateDelayOffset(float lfoSample) nothrow @nogc
    {
        if(_type == flanger || _type == vibrato)
        {
            //flanger 0->1 gets mapped to 0->maxdelay
            return modDepth * (lfoSample * (maxDelayMS - minDelayMS)) + minDelayMS; 
        }
        else if(_type = chorus)
        {
            float start = minDelayMS + chorusOffset;
            return modDepth * (lfoSample * (maxDelayMS - minDelayMS)) + start;
        }
    }
    
    override float getNextSample(float input) nothrow @nogc
    {
        
    }
    
    override void reset() nothrow @nogc
    {
        
    }
    
    void setModType(uint type)
    {
        _type = type;
    }

private:

    DDelay delayLine;
    CFOscillator oscillator;
    
    float minDelayMS;
    float maxDelayMS;
    float chorusOffset;
    float modDepth;
    
    float _feedback;
    
    uint _type;
    
}